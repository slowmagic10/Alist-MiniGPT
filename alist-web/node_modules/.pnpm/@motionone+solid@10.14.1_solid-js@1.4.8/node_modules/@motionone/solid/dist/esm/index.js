import { createComponent, mergeProps, Dynamic, memo, isServer } from 'solid-js/web';
import { createContext, onCleanup, onMount, useContext, runWithOwner, getOwner, createEffect, splitProps, untrack, children, createMemo, createSignal, createComputed, on, batch } from 'solid-js';
import { createStyles, style, createMotionState, mountedStates } from '@motionone/dom';
import { isFunction } from '@motionone/utils';
import { combineStyle } from '@solid-primitives/props';

const defaultPresenceContextState = {
  initial: () => true,
  addCleanup: onCleanup,
  addMount: onMount
};
const ParentContext = createContext();
const PresenceContext = createContext(defaultPresenceContextState);

/** @internal */
function createAndBindMotionState(target, options, presenceState, parentState) {
  const {
    addCleanup,
    addMount,
    initial
  } = presenceState;
  const state = createMotionState(initial() ? options() : { ...options(),
    initial: false
  }, parentState);
  addMount(runWithOwner.bind(void 0, getOwner(), () => {
    addCleanup(state.mount(target()));
    createEffect(() => state.update(options()));
  }));
  return state;
}
/**
 * createMotion provides MotionOne as a compact Solid primitive.
 *
 * @param target Target Element to animate.
 * @param options Options to effect the animation.
 * @param presenceState Optional PresenceContext override, defaults to current parent.
 * @returns Object to access MotionState
 */

function createMotion(target, options, presenceState = defaultPresenceContextState) {
  const getOptions = () => isFunction(options) ? options() : options;

  const state = createAndBindMotionState(() => target, getOptions, presenceState);
  const styles = createStyles(state.getTarget());

  for (const key in styles) {
    style.set(target, key, styles[key]);
  }

  return state;
}
/**
 * motion is a Solid directive that makes binding to elements easier.
 *
 * @param el Target Element to bind to.
 * @param props Options to effect the animation.
 */

function motion(el, props) {
  createMotion(el, props, useContext(PresenceContext));
}

/** @internal */

const MotionComponent = props => {
  const [options,, attrs] = splitProps(props, ["initial", "animate", "inView", "inViewOptions", "hover", "press", "variants", "transition", "exit"], ["tag", "ref", "style", "onMotionStart", "onMotionComplete", "onHoverStart", "onHoverEnd", "onPressStart", "onPressEnd", "onViewEnter", "onViewLeave"]);
  const state = createAndBindMotionState(() => root, () => ({ ...options
  }), useContext(PresenceContext), useContext(ParentContext));
  const style = createStyles(state.getTarget());
  let root;
  return createComponent(ParentContext.Provider, {
    value: state,

    get children() {
      return createComponent(Dynamic, mergeProps({
        ref: el => {
          root = el;
          props.ref?.(el);
        },

        get component() {
          return untrack(() => props.tag || "div");
        },

        get style() {
          return memo(() => !!props.style, true)() ? combineStyle(props.style, style) : style;
        },

        get ["on:motionstart"]() {
          return props.onMotionStart;
        },

        get ["on:motioncomplete"]() {
          return props.onMotionComplete;
        },

        get ["on:hoverstart"]() {
          return props.onHoverStart;
        },

        get ["on:hoverend"]() {
          return props.onHoverEnd;
        },

        get ["on:pressstart"]() {
          return props.onPressStart;
        },

        get ["on:pressend"]() {
          return props.onPressEnd;
        },

        get ["on:viewenter"]() {
          return props.onViewEnter;
        },

        get ["on:viewleave"]() {
          return props.onViewLeave;
        }

      }, attrs));
    }

  });
};
/**
 * Renders an animatable HTML or SVG element.
 *
 * @component
 * Animation props:
 * - `animate` a target of values to animate to. Accepts all the same values and keyframes as Motion One's [animate function](https://motion.dev/dom/animate). This prop is **reactive** – changing it will animate the transition element to the new state.
 * - `transition` for changing type of animation
 * - `initial` a target of values to animate from when the element is first rendered.
 * - `exit` a target of values to animate to when the element is removed. The element must be a direct child of the `<Presence>` component.
 *
 * @example
 * ```tsx
 * <Motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}/>
 * ```
 *
 * Interaction animation props:
 *
 * - `inView` animation target for when the element is in view
 * - `hover` animate when hovered
 * - `press` animate when pressed
 *
 * @example
 * ```tsx
 * <Motion.div hover={{ scale: 1.2 }} press={{ scale: 0.9 }}/>
 * ```
 */

const Motion = new Proxy(MotionComponent, {
  get: (_, tag) => props => {
    delete props.tag;
    return createComponent(MotionComponent, mergeProps(props, {
      tag: tag
    }));
  }
});

const getSingleElement = resolved => {
  resolved = Array.isArray(resolved) ? resolved[0] : resolved;
  return resolved instanceof Element ? resolved : undefined;
};

const addCompleteListener = (el, fn) => {
  const options = {
    once: true
  };
  el.addEventListener("motioncomplete", fn, options);
  onCleanup(el.removeEventListener.bind(el, "motioncomplete", fn, options));
};
/**
 * Perform exit/enter trantisions of children `<Motion>` components.
 *
 * accepts props:
 * - `initial` – *(Defaults to `true`)* – If `false`, will disable the first animation on all child `Motion` elements the first time `Presence` is rendered.
 * - `exitBeforeEnter` – *(Defaults to `false`)* – If `true`, `Presence` will wait for the exiting element to finish animating out before animating in the next one.
 *
 * @example
 * ```tsx
 * <Presence exitBeforeEnter>
 *   <Show when={toggle()}>
 *     <Motion.div
 *       initial={{ opacity: 0 }}
 *       animate={{ opacity: 1 }}
 *       exit={{ opacity: 0 }}
 *     />
 *   </Show>
 * </Presence>
 * ```
 */


const Presence = props => {
  let {
    initial = true
  } = props;
  onMount(() => initial = true);
  let exiting = false;
  let mounts = [];
  let newUnmounts = [];
  let exitUnmounts = [];
  onCleanup(() => {
    exitUnmounts.concat(newUnmounts).forEach(f => f());
    newUnmounts = exitUnmounts = mounts = [];
  });
  return createComponent(PresenceContext.Provider, {
    value: {
      addCleanup: fn => newUnmounts.push(fn),
      addMount: fn => mounts.push(fn),
      initial: () => initial
    },

    get children() {
      return createComponent(ParentContext.Provider, {
        value: undefined,

        get children() {
          return untrack(() => {
            if (isServer) return props.children; // children need to be accessed under a context provider

            const resolved = children(() => props.children);
            const resolvedChild = createMemo(() => getSingleElement(resolved()));
            const [el, setEl] = createSignal();
            const [el2, setEl2] = createSignal();
            createComputed(on(resolvedChild, newEl => {
              exitUnmounts.push(...newUnmounts);
              newUnmounts = [];
              batch(() => {
                // exit -> enter
                if (props.exitBeforeEnter) {
                  setEl();
                  exitTransition(() => !exiting && enterTransition(newEl));
                } // exit & enter
                else {
                  enterTransition(newEl);
                  exitTransition();
                }
              });
            }));
            return [el, el2];

            function enterTransition(el) {
              setEl(el);
              mounts.forEach(f => f());
              mounts = [];
            }

            function exitTransition(done) {
              const complete = () => {
                setEl2();
                exitUnmounts.forEach(f => f());
                exitUnmounts = [];
                done?.();
              };

              const exitEl = setEl2(el() ?? el2());
              if (!exitEl) return complete();
              const state = mountedStates.get(exitEl);
              if (!state || !state.getOptions().exit) return complete();
              state.setActive("exit", exiting = true);
              addCompleteListener(exitEl, () => {
                exiting = false;
                complete();
              });
            }
          });
        }

      });
    }

  });
};

export { Motion, Presence, PresenceContext, createMotion, motion };
//# sourceMappingURL=index.js.map
