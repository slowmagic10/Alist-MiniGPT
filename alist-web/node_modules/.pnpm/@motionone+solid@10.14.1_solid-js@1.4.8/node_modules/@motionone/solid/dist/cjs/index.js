'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var web = require('solid-js/web');
var solidJs = require('solid-js');
var dom = require('@motionone/dom');
var utils = require('@motionone/utils');
var props = require('@solid-primitives/props');

const defaultPresenceContextState = {
  initial: () => true,
  addCleanup: solidJs.onCleanup,
  addMount: solidJs.onMount
};
const ParentContext = solidJs.createContext();
const PresenceContext = solidJs.createContext(defaultPresenceContextState);

/** @internal */
function createAndBindMotionState(target, options, presenceState, parentState) {
  const {
    addCleanup,
    addMount,
    initial
  } = presenceState;
  const state = dom.createMotionState(initial() ? options() : { ...options(),
    initial: false
  }, parentState);
  addMount(solidJs.runWithOwner.bind(void 0, solidJs.getOwner(), () => {
    addCleanup(state.mount(target()));
    solidJs.createEffect(() => state.update(options()));
  }));
  return state;
}
/**
 * createMotion provides MotionOne as a compact Solid primitive.
 *
 * @param target Target Element to animate.
 * @param options Options to effect the animation.
 * @param presenceState Optional PresenceContext override, defaults to current parent.
 * @returns Object to access MotionState
 */

function createMotion(target, options, presenceState = defaultPresenceContextState) {
  const getOptions = () => utils.isFunction(options) ? options() : options;

  const state = createAndBindMotionState(() => target, getOptions, presenceState);
  const styles = dom.createStyles(state.getTarget());

  for (const key in styles) {
    dom.style.set(target, key, styles[key]);
  }

  return state;
}
/**
 * motion is a Solid directive that makes binding to elements easier.
 *
 * @param el Target Element to bind to.
 * @param props Options to effect the animation.
 */

function motion(el, props) {
  createMotion(el, props, solidJs.useContext(PresenceContext));
}

/** @internal */

const MotionComponent = props$1 => {
  const [options,, attrs] = solidJs.splitProps(props$1, ["initial", "animate", "inView", "inViewOptions", "hover", "press", "variants", "transition", "exit"], ["tag", "ref", "style", "onMotionStart", "onMotionComplete", "onHoverStart", "onHoverEnd", "onPressStart", "onPressEnd", "onViewEnter", "onViewLeave"]);
  const state = createAndBindMotionState(() => root, () => ({ ...options
  }), solidJs.useContext(PresenceContext), solidJs.useContext(ParentContext));
  const style = dom.createStyles(state.getTarget());
  let root;
  return web.createComponent(ParentContext.Provider, {
    value: state,

    get children() {
      return web.createComponent(web.Dynamic, web.mergeProps({
        ref: el => {
          root = el;
          props$1.ref?.(el);
        },

        get component() {
          return solidJs.untrack(() => props$1.tag || "div");
        },

        get style() {
          return web.memo(() => !!props$1.style, true)() ? props.combineStyle(props$1.style, style) : style;
        },

        get ["on:motionstart"]() {
          return props$1.onMotionStart;
        },

        get ["on:motioncomplete"]() {
          return props$1.onMotionComplete;
        },

        get ["on:hoverstart"]() {
          return props$1.onHoverStart;
        },

        get ["on:hoverend"]() {
          return props$1.onHoverEnd;
        },

        get ["on:pressstart"]() {
          return props$1.onPressStart;
        },

        get ["on:pressend"]() {
          return props$1.onPressEnd;
        },

        get ["on:viewenter"]() {
          return props$1.onViewEnter;
        },

        get ["on:viewleave"]() {
          return props$1.onViewLeave;
        }

      }, attrs));
    }

  });
};
/**
 * Renders an animatable HTML or SVG element.
 *
 * @component
 * Animation props:
 * - `animate` a target of values to animate to. Accepts all the same values and keyframes as Motion One's [animate function](https://motion.dev/dom/animate). This prop is **reactive** – changing it will animate the transition element to the new state.
 * - `transition` for changing type of animation
 * - `initial` a target of values to animate from when the element is first rendered.
 * - `exit` a target of values to animate to when the element is removed. The element must be a direct child of the `<Presence>` component.
 *
 * @example
 * ```tsx
 * <Motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }}/>
 * ```
 *
 * Interaction animation props:
 *
 * - `inView` animation target for when the element is in view
 * - `hover` animate when hovered
 * - `press` animate when pressed
 *
 * @example
 * ```tsx
 * <Motion.div hover={{ scale: 1.2 }} press={{ scale: 0.9 }}/>
 * ```
 */

const Motion = new Proxy(MotionComponent, {
  get: (_, tag) => props => {
    delete props.tag;
    return web.createComponent(MotionComponent, web.mergeProps(props, {
      tag: tag
    }));
  }
});

const getSingleElement = resolved => {
  resolved = Array.isArray(resolved) ? resolved[0] : resolved;
  return resolved instanceof Element ? resolved : undefined;
};

const addCompleteListener = (el, fn) => {
  const options = {
    once: true
  };
  el.addEventListener("motioncomplete", fn, options);
  solidJs.onCleanup(el.removeEventListener.bind(el, "motioncomplete", fn, options));
};
/**
 * Perform exit/enter trantisions of children `<Motion>` components.
 *
 * accepts props:
 * - `initial` – *(Defaults to `true`)* – If `false`, will disable the first animation on all child `Motion` elements the first time `Presence` is rendered.
 * - `exitBeforeEnter` – *(Defaults to `false`)* – If `true`, `Presence` will wait for the exiting element to finish animating out before animating in the next one.
 *
 * @example
 * ```tsx
 * <Presence exitBeforeEnter>
 *   <Show when={toggle()}>
 *     <Motion.div
 *       initial={{ opacity: 0 }}
 *       animate={{ opacity: 1 }}
 *       exit={{ opacity: 0 }}
 *     />
 *   </Show>
 * </Presence>
 * ```
 */


const Presence = props => {
  let {
    initial = true
  } = props;
  solidJs.onMount(() => initial = true);
  let exiting = false;
  let mounts = [];
  let newUnmounts = [];
  let exitUnmounts = [];
  solidJs.onCleanup(() => {
    exitUnmounts.concat(newUnmounts).forEach(f => f());
    newUnmounts = exitUnmounts = mounts = [];
  });
  return web.createComponent(PresenceContext.Provider, {
    value: {
      addCleanup: fn => newUnmounts.push(fn),
      addMount: fn => mounts.push(fn),
      initial: () => initial
    },

    get children() {
      return web.createComponent(ParentContext.Provider, {
        value: undefined,

        get children() {
          return solidJs.untrack(() => {
            if (web.isServer) return props.children; // children need to be accessed under a context provider

            const resolved = solidJs.children(() => props.children);
            const resolvedChild = solidJs.createMemo(() => getSingleElement(resolved()));
            const [el, setEl] = solidJs.createSignal();
            const [el2, setEl2] = solidJs.createSignal();
            solidJs.createComputed(solidJs.on(resolvedChild, newEl => {
              exitUnmounts.push(...newUnmounts);
              newUnmounts = [];
              solidJs.batch(() => {
                // exit -> enter
                if (props.exitBeforeEnter) {
                  setEl();
                  exitTransition(() => !exiting && enterTransition(newEl));
                } // exit & enter
                else {
                  enterTransition(newEl);
                  exitTransition();
                }
              });
            }));
            return [el, el2];

            function enterTransition(el) {
              setEl(el);
              mounts.forEach(f => f());
              mounts = [];
            }

            function exitTransition(done) {
              const complete = () => {
                setEl2();
                exitUnmounts.forEach(f => f());
                exitUnmounts = [];
                done?.();
              };

              const exitEl = setEl2(el() ?? el2());
              if (!exitEl) return complete();
              const state = dom.mountedStates.get(exitEl);
              if (!state || !state.getOptions().exit) return complete();
              state.setActive("exit", exiting = true);
              addCompleteListener(exitEl, () => {
                exiting = false;
                complete();
              });
            }
          });
        }

      });
    }

  });
};

exports.Motion = Motion;
exports.Presence = Presence;
exports.PresenceContext = PresenceContext;
exports.createMotion = createMotion;
exports.motion = motion;
//# sourceMappingURL=index.js.map
