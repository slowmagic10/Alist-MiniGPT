"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  access: () => access,
  accessArray: () => accessArray,
  accessWith: () => accessWith,
  arrayEquals: () => arrayEquals,
  asAccessor: () => asAccessor,
  asArray: () => asArray,
  chain: () => chain,
  clamp: () => clamp,
  compare: () => compare,
  createCallbackStack: () => createCallbackStack,
  createMicrotask: () => createMicrotask,
  createProxy: () => createProxy,
  createStaticStore: () => createStaticStore,
  createTrigger: () => createTrigger,
  createTriggerCache: () => createTriggerCache,
  createWeakTriggerCache: () => createWeakTriggerCache,
  entries: () => entries,
  forEachEntry: () => forEachEntry,
  handleDiffArray: () => handleDiffArray,
  isClient: () => isClient,
  isDev: () => isDev,
  isObject: () => isObject,
  isProd: () => isProd,
  isServer: () => isServer,
  keys: () => keys,
  noop: () => noop,
  ofClass: () => ofClass,
  onRootCleanup: () => onRootCleanup,
  warn: () => warn,
  withAccess: () => withAccess
});
module.exports = __toCommonJS(src_exports);
var import_solid_js = require("solid-js");
var import_web = require("solid-js/web");
var noop = () => void 0;
var isServer = import_web.isServer;
var isClient = !isServer;
var isDev = import_solid_js.DEV && isClient;
var isProd = !isDev;
var warn = (...a) => isDev && console.warn(...a);
var ofClass = (v, c) => v instanceof c || v && v.constructor === c;
function isObject(value) {
  return value !== null && (typeof value === "object" || typeof value === "function");
}
var compare = (a, b) => a < b ? -1 : a > b ? 1 : 0;
var arrayEquals = (a, b) => a === b || a.length === b.length && a.every((e, i) => e === b[i]);
function chain(callbacks) {
  return (...args) => {
    for (const callback of callbacks) {
      if (typeof callback === "function")
        callback(...args);
    }
  };
}
var clamp = (n, min, max) => Math.min(Math.max(n, min), max);
var access = (v) => typeof v === "function" && !v.length ? v() : v;
var asArray = (value) => Array.isArray(value) ? value : [value];
var accessArray = (list) => list.map((v) => access(v));
var withAccess = (value, fn) => {
  const _value = access(value);
  typeof _value !== "undefined" && _value !== null && fn(_value);
};
var asAccessor = (v) => typeof v === "function" ? v : () => v;
function accessWith(valueOrFn, ...args) {
  return typeof valueOrFn === "function" ? valueOrFn(...args) : valueOrFn;
}
function forEachEntry(object, iterator) {
  Object.entries(object).forEach(
    ([key, item], index, pairs) => iterator(key, item, index, pairs, object)
  );
}
var entries = Object.entries;
var keys = Object.keys;
var onRootCleanup = (fn) => (0, import_solid_js.getOwner)() ? (0, import_solid_js.onCleanup)(fn) : fn;
var createCallbackStack = () => {
  let stack = [];
  const clear = () => stack = [];
  return {
    push: (...callbacks) => stack.push(...callbacks),
    execute(arg0, arg1, arg2, arg3) {
      stack.forEach((cb) => cb(arg0, arg1, arg2, arg3));
      clear();
    },
    clear
  };
};
function createMicrotask(fn) {
  let calls = 0;
  let args;
  return (...a) => {
    args = a, calls++;
    queueMicrotask(() => --calls === 0 && fn(...args));
  };
}
function createProxy(traps) {
  return new Proxy(
    {},
    {
      get: (_, k) => traps.get(k),
      set: (_, k, v) => {
        var _a;
        (_a = traps.set) == null ? void 0 : _a.call(traps, k, v);
        return false;
      }
    }
  );
}
var createTrigger = isDev ? () => (0, import_solid_js.createSignal)(void 0, { equals: false, name: "trigger" }) : () => (0, import_solid_js.createSignal)(void 0, { equals: false });
function dirtyTriggerCache(key) {
  const trigger = this.get(key);
  if (trigger)
    trigger[1]();
}
function dirtyAllTriggerCache() {
  this.forEach((s) => s[1]());
}
function trackTriggerCache(key) {
  if (!(0, import_solid_js.getListener)())
    return;
  let trigger = this.get(key);
  if (!trigger) {
    trigger = createTrigger();
    this.set(key, trigger);
  }
  trigger[0]();
}
function createTriggerCache() {
  const cache = /* @__PURE__ */ new Map();
  return {
    dirty: dirtyTriggerCache.bind(cache),
    dirtyAll: dirtyAllTriggerCache.bind(cache),
    track: trackTriggerCache.bind(cache)
  };
}
function createWeakTriggerCache() {
  const cache = /* @__PURE__ */ new WeakMap();
  return {
    dirty: dirtyTriggerCache.bind(cache),
    track: trackTriggerCache.bind(cache)
  };
}
function createStaticStore(init) {
  const copy = { ...init };
  const store = {};
  const cache = /* @__PURE__ */ new Map();
  const getValue = (key) => {
    const saved = cache.get(key);
    if (saved)
      return saved[0]();
    const signal = (0, import_solid_js.createSignal)(copy[key], {
      name: typeof key === "string" ? key : void 0
    });
    cache.set(key, signal);
    delete copy[key];
    return signal[0]();
  };
  const setValue = (key, value) => {
    const saved = cache.get(key);
    if (saved)
      return saved[1](value);
    if (key in copy)
      copy[key] = accessWith(value, [copy[key]]);
  };
  for (const key of keys(init)) {
    store[key] = void 0;
    Object.defineProperty(store, key, {
      get: getValue.bind(void 0, key)
    });
  }
  const setter = (a, b) => {
    if (isObject(a))
      (0, import_solid_js.untrack)(() => {
        (0, import_solid_js.batch)(() => {
          for (const [key, value] of entries(accessWith(a, store)))
            setValue(key, () => value);
        });
      });
    else
      setValue(a, b);
    return store;
  };
  return [store, setter];
}
function handleDiffArray(current, prev, handleAdded, handleRemoved) {
  const currLength = current.length;
  const prevLength = prev.length;
  let i = 0;
  if (!prevLength) {
    for (; i < currLength; i++)
      handleAdded(current[i]);
    return;
  }
  if (!currLength) {
    for (; i < prevLength; i++)
      handleRemoved(prev[i]);
    return;
  }
  for (; i < prevLength; i++) {
    if (prev[i] !== current[i])
      break;
  }
  let prevEl;
  let currEl;
  prev = prev.slice(i);
  current = current.slice(i);
  for (prevEl of prev) {
    if (!current.includes(prevEl))
      handleRemoved(prevEl);
  }
  for (currEl of current) {
    if (!prev.includes(currEl))
      handleAdded(currEl);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  access,
  accessArray,
  accessWith,
  arrayEquals,
  asAccessor,
  asArray,
  chain,
  clamp,
  compare,
  createCallbackStack,
  createMicrotask,
  createProxy,
  createStaticStore,
  createTrigger,
  createTriggerCache,
  createWeakTriggerCache,
  entries,
  forEachEntry,
  handleDiffArray,
  isClient,
  isDev,
  isObject,
  isProd,
  isServer,
  keys,
  noop,
  ofClass,
  onRootCleanup,
  warn,
  withAccess
});
