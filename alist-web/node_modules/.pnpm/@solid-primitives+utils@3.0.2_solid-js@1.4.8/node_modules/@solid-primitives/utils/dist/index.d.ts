import { Accessor, Setter, onCleanup } from 'solid-js';

/**
 * Can be single or in an array
 */
declare type Many<T> = T | T[];
declare type Values<O extends Object> = O[keyof O];
declare type Noop = (...a: any[]) => void;
declare type Directive<P = true> = (el: Element, props: Accessor<P>) => void;
/**
 * Infers the type of the array elements
 */
declare type ItemsOf<T> = T extends (infer E)[] ? E : never;
declare type ItemsOfMany<T> = T extends any[] ? ItemsOf<T> : T;
declare type SetterValue<T> = Parameters<Setter<T>>[0];
/**
 * T or a reactive/non-reactive function returning T
 */
declare type MaybeAccessor<T> = T | Accessor<T>;
/**
 * Accessed value of a MaybeAccessor
 * @example
 * ```ts
 * MaybeAccessorValue<MaybeAccessor<string>>
 * // => string
 * MaybeAccessorValue<MaybeAccessor<() => string>>
 * // => string | (() => string)
 * MaybeAccessorValue<MaybeAccessor<string> | Function>
 * // => string | void
 * ```
 */
declare type MaybeAccessorValue<T extends MaybeAccessor<any>> = T extends () => any ? ReturnType<T> : T;
declare type OnAccessEffectFunction<S, Prev, Next extends Prev = Prev> = (input: AccessReturnTypes<S>, prevInput: AccessReturnTypes<S>, v: Prev) => Next;
declare type AccessReturnTypes<S> = S extends MaybeAccessor<any>[] ? {
    [I in keyof S]: AccessReturnTypes<S[I]>;
} : MaybeAccessorValue<S>;
/** Allows to make shallow overwrites to an interface */
declare type Modify<T, R> = Omit<T, keyof R> & R;
/** Allows to make nested overwrites to an interface */
declare type ModifyDeep<A extends AnyObject, B extends DeepPartialAny<A>> = {
    [K in keyof A]: B[K] extends never ? A[K] : B[K] extends AnyObject ? ModifyDeep<A[K], B[K]> : B[K];
} & (A extends AnyObject ? Omit<B, keyof A> : A);
/** Makes each property optional and turns each leaf property into any, allowing for type overrides by narrowing any. */
declare type DeepPartialAny<T> = {
    [P in keyof T]?: T[P] extends AnyObject ? DeepPartialAny<T[P]> : any;
};
/** Removes the `[...list]` functionality */
declare type NonIterable<T> = T & {
    [Symbol.iterator]: never;
};
/** An opposite of `Partial`. Makes all the keys required. */
declare type Definite<T> = {
    [K in keyof T]-?: T[K];
};
/** An opposite of `Readonly`. Makes all the params mutable. */
declare type Mutable<T> = {
    -readonly [K in keyof T]: T[K];
};
/** Unwraps the type definition of an object, making it more readable */
declare type Simplify<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
/** Unboxes type definition, making it more readable */
declare type UnboxLazy<T> = T extends () => infer U ? U : T;
/** Get the required keys of an object */
declare type RequiredKeys<T> = keyof {
    [K in keyof T as T extends {
        [_ in K]: unknown;
    } ? K : never]: 0;
};
/** Remove the first item of a tuple [1, 2, 3, 4] => [2, 3, 4] */
declare type Tail<T extends any[]> = ((...t: T) => void) extends (x: any, ...u: infer U) => void ? U : never;
/** `A | B => A & B` */
declare type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;
declare type ExtractIfPossible<T, U> = Extract<T, U> extends never ? U : Extract<T, U>;
declare type AnyObject = Record<PropertyKey, any>;
declare type AnyStatic = [] | any[] | AnyObject;
declare type AnyFunction = (...args: any[]) => any;
declare type AnyClass = abstract new (...args: any) => any;
declare type PrimitiveValue = PropertyKey | boolean | bigint | null | undefined;
declare type FalsyValue = false | 0 | "" | null | undefined;
declare type Truthy<T> = Exclude<T, FalsyValue>;
declare type Falsy<T> = Extract<T, FalsyValue>;
declare type Position = {
    x: number;
    y: number;
};

/** no operation */
declare const noop: Noop;
declare const isServer: boolean;
declare const isClient = true;
/** development environment */
declare const isDev = true;
/** production environment */
declare const isProd = false;
/** `console.warn` only during development */
declare const warn: typeof console.warn;
/**
 * Check if the value is an instance of ___
 */
declare const ofClass: (v: any, c: AnyClass) => boolean;
/** Check if value is typeof "object" or "function" */
declare function isObject(value: any): value is AnyObject;
declare const compare: (a: any, b: any) => number;
/**
 * Check shallow array equality
 */
declare const arrayEquals: (a: readonly unknown[], b: readonly unknown[]) => boolean;
/**
 * Returns a function that will call all functions in the order they were chained with the same arguments.
 */
declare function chain<Args extends [] | any[]>(callbacks: {
    [Symbol.iterator](): IterableIterator<((...args: Args) => any) | undefined>;
}): (...args: Args) => void;
declare const clamp: (n: number, min: number, max: number) => number;
/**
 * Accesses the value of a MaybeAccessor
 * @example
 * ```ts
 * access("foo") // => "foo"
 * access(() => "foo") // => "foo"
 * ```
 */
declare const access: <T extends unknown>(v: T) => MaybeAccessorValue<T>;
declare const asArray: <T>(value: T) => T extends any[] ? T : T[];
/**
 * Access an array of MaybeAccessors
 * @example
 * const list = [1, 2, () => 3)] // T: MaybeAccessor<number>[]
 * const newList = accessArray(list) // T: number[]
 */
declare const accessArray: <A extends unknown>(list: readonly A[]) => MaybeAccessorValue<A>[];
/**
 * Run the function if the accessed value is not `undefined` nor `null`
 * @param value
 * @param fn
 */
declare const withAccess: <T, A extends MaybeAccessor<T>, V = MaybeAccessorValue<A>>(value: A, fn: (value: NonNullable<V>) => void) => void;
declare const asAccessor: <A extends unknown>(v: A) => Accessor<MaybeAccessorValue<A>>;
/** If value is a function – call it with a given arguments – otherwise get the value as is */
declare function accessWith<T>(valueOrFn: T, ...args: T extends AnyFunction ? Parameters<T> : never): T extends AnyFunction ? ReturnType<T> : T;
/**
 * Iterate through object entries.
 */
declare function forEachEntry<O extends AnyObject>(object: O, iterator: (key: keyof O, item: Values<O>, index: number, pairs: [keyof O, Values<O>][], object: O) => void): void;
/**
 * Get entries of an object
 */
declare const entries: <T extends object>(obj: T) => [keyof T, T[keyof T]][];
/**
 * Get keys of an object
 */
declare const keys: <T extends object>(object: T) => (keyof T)[];
/**
 * Solid's `onCleanup` that is registered only if there is a root.
 */
declare const onRootCleanup: typeof onCleanup;
declare const createCallbackStack: <A0 = void, A1 = void, A2 = void, A3 = void>() => {
    push: (...callbacks: ((arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void)[]) => void;
    execute: (arg0: A0, arg1: A1, arg2: A2, arg3: A3) => void;
    clear: VoidFunction;
};
/**
 * Group synchronous function calls.
 * @param fn
 * @returns `fn`
 */
declare function createMicrotask<A extends any[] | []>(fn: (...a: A) => void): (...a: A) => void;
/** WIP: an easier to setup and type Proxy */
declare function createProxy<T extends Record<string | symbol, any>>(traps: {
    get: <K extends keyof T>(key: K) => T[K];
    set: <K extends keyof T>(key: K, value: T[K]) => void;
}): T;
declare function createProxy<T extends Record<string | symbol, any>>(traps: {
    get: <K extends keyof T>(key: K) => T[K];
    set?: undefined;
}): Readonly<T>;
declare type Trigger = [track: VoidFunction, dirty: VoidFunction];
/**
 * Set listeners in reactive computations and then trigger them when you want.
 * @returns `[track function, dirty function]`
 * @example
 * const [track, dirty] = createTrigger()
 * createEffect(() => {
 *    track()
 *    ...
 * })
 * // later
 * dirty()
 */
declare const createTrigger: () => Trigger;
declare type TriggerCache<T> = {
    track: (v: T) => void;
    dirty: (v: T) => void;
    dirtyAll: VoidFunction;
};
/**
 * Set listeners in reactive computations and then trigger them when you want. Cache trackers by a `key`.
 * @returns `{ track, dirty, dirtyAll }` functions
 * `track` and `dirty` are called with a `key` so that each tracker will trigger an update only when his individual `key` would get marked as dirty.
 * @example
 * const { track, dirty } = createTriggerCache()
 * createEffect(() => {
 *    track(1)
 *    ...
 * })
 * // later
 * dirty(1)
 * // this won't cause an update:
 * dirty(2)
 */
declare function createTriggerCache<T>(): TriggerCache<T>;
declare type WeakTriggerCache<T extends object> = {
    track: (v: T) => void;
    dirty: (v: T) => void;
};
/**
 * Set listeners in reactive computations and then trigger them when you want. Cache trackers by a `key`.
 * @returns `{ track, dirty }` functions
 * `track` and `dirty` are called with a `key` so that each tracker will trigger an update only when his individual `key` would get marked as dirty.
 * @example
 * const { track, dirty } = createWeakTriggerCache()
 * createEffect(() => {
 *    track(1)
 *    ...
 * })
 * // later
 * dirty(1)
 * // this won't cause an update:
 * dirty(2)
 */
declare function createWeakTriggerCache<T extends object>(): WeakTriggerCache<T>;
declare type StaticStoreSetter<T extends Readonly<AnyStatic>> = {
    (setter: (prev: T) => Partial<T>): T;
    (state: Partial<T>): T;
    <K extends keyof T>(key: K, state: SetterValue<T[K]>): T;
};
/**
 * A shallowly wrapped reactive store object. It behaves similarly to the createStore, but with limited features to keep it simple. Designed to be used for reactive objects with static keys, but dynamic values, like reactive Event State, location, etc.
 * @param init initial value of the store
 * @returns
 * ```ts
 * [access: Readonly<T>, write: StaticStoreSetter<T>]
 * ```
 */
declare function createStaticStore<T extends Readonly<AnyStatic>>(init: T): [access: T, write: StaticStoreSetter<T>];
/**
 * Handle items removed and added to the array by diffing it by refference.
 *
 * @param current new array instance
 * @param prev previous array copy
 * @param handleAdded called once for every added item to array
 * @param handleRemoved called once for every removed from array
 */
declare function handleDiffArray<T>(current: readonly T[], prev: readonly T[], handleAdded: (item: T) => void, handleRemoved: (item: T) => void): void;

export { AccessReturnTypes, AnyClass, AnyFunction, AnyObject, AnyStatic, DeepPartialAny, Definite, Directive, ExtractIfPossible, Falsy, FalsyValue, ItemsOf, ItemsOfMany, Many, MaybeAccessor, MaybeAccessorValue, Modify, ModifyDeep, Mutable, NonIterable, Noop, OnAccessEffectFunction, Position, PrimitiveValue, RequiredKeys, SetterValue, Simplify, StaticStoreSetter, Tail, Trigger, TriggerCache, Truthy, UnboxLazy, UnionToIntersection, Values, WeakTriggerCache, access, accessArray, accessWith, arrayEquals, asAccessor, asArray, chain, clamp, compare, createCallbackStack, createMicrotask, createProxy, createStaticStore, createTrigger, createTriggerCache, createWeakTriggerCache, entries, forEachEntry, handleDiffArray, isClient, isDev, isObject, isProd, isServer, keys, noop, ofClass, onRootCleanup, warn, withAccess };
