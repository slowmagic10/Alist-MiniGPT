import { chain } from "@solid-primitives/utils";
import { mergeProps } from "solid-js";
const extractCSSregex = /([^:; ]*):\s*([^;]*)/g;
const isEventListenerKey = (key) => key[0] === "o" &&
    key[1] === "n" &&
    key.length > 2 &&
    key[2] !== ":" &&
    !key.startsWith("oncapture:");
/**
 * converts inline string styles to object form
 * @example
 * const styles = stringStyleToObject("margin: 24px; border: 1px solid #121212");
 * styles; // { margin: "24px", border: "1px solid #121212" }
 * */
export function stringStyleToObject(style) {
    const object = {};
    let match;
    while ((match = extractCSSregex.exec(style))) {
        object[match[1]] = match[2];
    }
    return object;
}
export function combineStyle(a, b) {
    if (typeof a === "object" && typeof b === "object")
        return { ...a, ...b };
    if (typeof a === "string" && typeof b === "string")
        return `${a};${b}`;
    const objA = typeof a === "object" ? a : stringStyleToObject(a);
    const objB = typeof b === "object" ? b : stringStyleToObject(b);
    return { ...objA, ...objB };
}
/**
 * A helper that reactively merges multiple props objects together while smartly combining some of Solid's JSX/DOM attributes.
 *
 * Event handlers and refs are chained, class, classNames and styles are combined.
 * For all other props, the last prop object overrides all previous ones. Similarly to {@link mergeProps}
 * @param sources - Multiple sets of props to combine together.
 * @example
 * ```tsx
 * const MyButton: Component<ButtonProps> = props => {
 *    const { buttonProps } = createButton();
 *    const combined = combineProps(props, buttonProps);
 *    return <button {...combined} />
 * }
 * // component consumer can provide button props
 * // they will be combined with those provided by createButton() primitive
 * <MyButton style={{ margin: "24px" }} />
 * ```
 */
export function combineProps(...sources) {
    if (sources.length === 1)
        return sources[0];
    const merge = mergeProps(...sources);
    const reduce = (key, calc) => {
        let v = undefined;
        for (const props of sources) {
            const propV = props[key];
            if (!v)
                v = propV;
            else if (propV)
                v = calc(v, propV);
        }
        return v;
    };
    // create a map of event listeners to be chained
    const listeners = {};
    for (const props of sources) {
        for (const key in props) {
            if (!isEventListenerKey(key))
                continue;
            const v = props[key];
            const name = key.toLowerCase();
            let callback;
            if (typeof v === "function")
                callback = v;
            // jsx event listeners also accept a tuple [handler, arg]
            else if (Array.isArray(v)) {
                if (v.length === 1)
                    callback = v[0];
                else
                    callback = v[0].bind(void 0, v[1]);
            }
            else {
                delete listeners[name];
                continue;
            }
            const callbacks = listeners[name];
            if (!callbacks)
                listeners[name] = [callback];
            else
                callbacks.push(callback);
        }
    }
    return new Proxy(merge, {
        get(target, key) {
            if (typeof key !== "string")
                return Reflect.get(target, key);
            // Combine style prop
            if (key === "style")
                return reduce("style", combineStyle);
            // chain props.ref assignments
            if (key === "ref") {
                const callbacks = [];
                for (const props of sources) {
                    const cb = props[key];
                    if (typeof cb === "function")
                        callbacks.push(cb);
                }
                return chain(callbacks);
            }
            // Chain event listeners
            if (isEventListenerKey(key)) {
                const callbacks = listeners[key.toLowerCase()];
                return Array.isArray(callbacks) ? chain(callbacks) : Reflect.get(target, key);
            }
            // Merge classes or classNames
            if (key === "class" || key === "className")
                return reduce(key, (a, b) => `${a} ${b}`);
            // Merge classList objects, keys in the last object overrides all previous ones.
            if (key === "classList")
                return reduce(key, (a, b) => ({ ...a, ...b }));
            return Reflect.get(target, key);
        }
    });
}
// const com = combineProps(
//   {
//     onSomething: 123,
//     onWheel: (e: WheelEvent) => 213,
//     something: "foo",
//     style: { margin: "24px" },
//     once: true,
//     onMount: (fn: VoidFunction) => undefined
//   },
//   {
//     onSomething: [(n: number, s: string) => "fo", 123],
//     once: "ovv"
//   },
//   {
//     onWheel: false,
//     onMount: (n: number) => void 0
//   }
// );
// com.onSomething; // (s: string) => void;
// com.once; // string;
// com.onWheel; // false;
// com.onMount; // ((fn: VoidFunction) => undefined) & ((n: number) => undefined);
// com.something; // string;
// com.style; // string | JSX.CSSProperties;
