import { $PROXY, createMemo, For, createSignal, mergeProps } from 'solid-js';
import { insert, effect, setAttribute, createComponent, template } from 'solid-js/web';
import { chain } from '@solid-primitives/utils';

function trueFn() {
  return true;
}

const propTraps = {
  get(_, property, receiver) {
    if (property === $PROXY) return receiver;
    return _.get(property);
  },

  has(_, property) {
    return _.has(property);
  },

  set: trueFn,
  deleteProperty: trueFn,

  getOwnPropertyDescriptor(_, property) {
    return {
      configurable: true,
      enumerable: true,

      get() {
        return _.get(property);
      },

      set: trueFn,
      deleteProperty: trueFn
    };
  },

  ownKeys(_) {
    return _.keys();
  }

};

const _tmpl$ = /*#__PURE__*/template(`<label><input type="checkbox"> <span></span> </label>`, 5),
      _tmpl$2 = /*#__PURE__*/template(`<label><span></span> <input type="number"> </label>`, 5),
      _tmpl$3 = /*#__PURE__*/template(`<label><span></span> <input type="text"> </label>`, 5),
      _tmpl$4 = /*#__PURE__*/template(`<label><span></span> <select></select> </label>`, 6),
      _tmpl$5 = /*#__PURE__*/template(`<option>"options missing"</option>`, 2),
      _tmpl$6 = /*#__PURE__*/template(`<option></option>`, 2);
const BoolProp = props => (() => {
  const _el$ = _tmpl$.cloneNode(true),
        _el$2 = _el$.firstChild,
        _el$3 = _el$2.nextSibling,
        _el$4 = _el$3.nextSibling;

  _el$2.addEventListener("change", ev => props.setValue(ev.currentTarget.checked));

  insert(_el$4, () => props.name);

  effect(() => setAttribute(_el$2, "name", props.name));

  effect(() => _el$2.checked = props.value());

  return _el$;
})();
const NumberProp = props => (() => {
  const _el$5 = _tmpl$2.cloneNode(true),
        _el$6 = _el$5.firstChild,
        _el$7 = _el$6.nextSibling,
        _el$8 = _el$7.nextSibling;

  insert(_el$6, () => props.name);

  _el$8.addEventListener("change", ev => props.setValue(ev.currentTarget.valueAsNumber));

  effect(_p$ => {
    const _v$ = props.name,
          _v$2 = props.min,
          _v$3 = props.max;
    _v$ !== _p$._v$ && setAttribute(_el$8, "name", _p$._v$ = _v$);
    _v$2 !== _p$._v$2 && setAttribute(_el$8, "min", _p$._v$2 = _v$2);
    _v$3 !== _p$._v$3 && setAttribute(_el$8, "max", _p$._v$3 = _v$3);
    return _p$;
  }, {
    _v$: undefined,
    _v$2: undefined,
    _v$3: undefined
  });

  effect(() => _el$8.value = props.value());

  return _el$5;
})();
const StringProp = props => (() => {
  const _el$9 = _tmpl$3.cloneNode(true),
        _el$10 = _el$9.firstChild,
        _el$11 = _el$10.nextSibling,
        _el$12 = _el$11.nextSibling;

  insert(_el$10, () => props.name);

  _el$12.addEventListener("change", ev => props.setValue(ev.currentTarget.value));

  effect(() => setAttribute(_el$12, "name", props.name));

  effect(() => _el$12.value = props.value());

  return _el$9;
})();

const filterEnum = options => {
  const entries = Object.entries(options);

  if (Object.keys(options).every(key => key === options[options[key]].toString())) {
    return entries.reduce((items, [key, value]) => {
      if (!items.includes(key)) {
        items.push(value);
      }

      return items;
    }, []).map(item => [item, options[item]]);
  }

  console.log(":(");
  return entries;
};

const SelectProp = props => {
  const options = createMemo(() => Array.isArray(props.options) ? props.options.map(option => [option, option]) : filterEnum(props.options));
  const initialValue = options().findIndex(([_, value]) => value === props.value());
  return (() => {
    const _el$13 = _tmpl$4.cloneNode(true),
          _el$14 = _el$13.firstChild,
          _el$15 = _el$14.nextSibling,
          _el$16 = _el$15.nextSibling;

    insert(_el$14, () => props.name);

    _el$16.addEventListener("change", ev => props.setValue(options()[ev.currentTarget.selectedIndex][1]));

    insert(_el$16, createComponent(For, {
      get each() {
        return options();
      },

      get fallback() {
        return _tmpl$5.cloneNode(true);
      },

      children: ([key], index) => (() => {
        const _el$18 = _tmpl$6.cloneNode(true);

        insert(_el$18, key);

        effect(() => _el$18.value = index());

        return _el$18;
      })()
    }));

    effect(() => setAttribute(_el$16, "name", props.name));

    effect(() => _el$16.value = initialValue.toString());

    return _el$13;
  })();
};
const defaultInitialValues = {
  boolean: false,
  number: 0,
  string: "",
  object: undefined
};
/**
 * creates a getter, a setter and a form control for a single prop
 *
 * @param name {string} The name of the property
 * @param options initialValue or Options object
 *
 * @example ```ts
 * createControlledProp('value', 'test');
 * createControlledProp('page', { initialValue: 7, min: 1, max: 99 });
 * createControlledProp('language', {
 *   initialValue: 'en',
 *   options: ['en', 'de', 'it', 'jp', 'cn', 'xy']
 * });
 * // => { value: Accessor<string>, setValue: Setter<string>, field: Component }
 * ```
 */

function createControlledProp(name, options) {
  const initialValue = options == null ? undefined : typeof options !== "object" ? options : options.initialValue ?? defaultInitialValues[options.type ?? "object"];

  if (initialValue == null) {
    throw new Error(`cannot get type for Prop ${name}`);
  }

  const propType = options?.options ? "object" : options?.type ?? typeof initialValue;
  const [value, setValue] = createSignal(initialValue, {
    name
  });
  return [value, setValue, propType === "boolean" ? () => BoolProp({
    name,
    value: value,
    setValue: setValue
  }) : propType === "number" ? () => NumberProp({
    name,
    value: value,
    setValue: setValue
  }) : propType === "string" ? () => StringProp({
    name,
    value: value,
    setValue: setValue
  }) : () => SelectProp({
    name,
    value: value,
    setValue: setValue,
    options: options.options ?? [initialValue]
  })];
}

/**
 * creates reactive props for testing a component
 *
 * @param props {Record<string, TestPropOptions>}
 * @returns ```ts
 * [
 *   props: { [name: string]: Accessor<T>, [setName: string]: Setter<T> }
 *   fields: JSX.Element[]
 * ]
 * ```
 * You get the fields to render the prop controls and getter and setter names derived from the name in `props` based on common practice, i.e. `count` would automatically translate to
 * ```ts
 * { count: Accessor<T>, getCount: Setter<T> }
 * ```
 * @example ```ts
 * const [props, fields] = createControlledProps({
 *   value: { initialValue: '' },
 *   disabled: { initialValue: false },
 *   invalid: { initialValue: false },
 *   type: { initialValue: 'text', options: ['text', 'password', 'email'] }
 * })
 * return <>
 *   <Input {...props} />
 *   {fields}
 * </>
 * ```
 */
const createControlledProps = props => Object.entries(props).reduce((result, [name, options]) => {
  const [value, setValue, field] = createControlledProp(name, options);
  result[0][name] = value;
  result[0][`set${name.slice(0, 1).toUpperCase()}${name.slice(1)}`] = setValue;
  result[1].push(field({}));
  return result;
}, [{}, []]);

/**
 * An alternative primitive to Solid's [splitProps](https://www.solidjs.com/docs/latest/api#splitprops) allowing you to create a new props object with only the property names that match the predicate.
 *
 * The predicate is run for every property read lazily, instead of calculated eagerly like the original splitProps. Any signal accessed within the `predicate` will be tracked, and `predicate` re-executed if changed.
 *
 * @param props The props object to filter.
 * @param predicate A function that returns `true` if the property should be included in the filtered object.
 * @returns A new props object with only the properties that match the predicate.
 *
 * @example
 * ```tsx
 * const dataProps = filterProps(props, key => key.startsWith("data-"));
 * <div {...dataProps} />
 * ```
 */

function filterProps(props, predicate) {
  return new Proxy({
    get(property) {
      return property in props && predicate(property) ? props[property] : undefined;
    },

    has(property) {
      return property in props && predicate(property);
    },

    keys() {
      return Object.keys(props).filter(predicate);
    }

  }, propTraps);
}
/**
 * Creates a predicate function that can be used to filter props by the prop name dynamically.
 *
 * The provided {@link predicate} function get's wrapped with a cache layer to prevent unnecessary re-evaluation. If one property is requested multiple times, the predicate function will only be evaluated once.
 *
 * The cache is only cleared when the keys of the props object change. *(when spreading props from a singal)*
 *
 * @param props The props object to filter.
 * @param predicate A function that returns `true` if the property should be included in the filtered object.
 * @returns A cached predicate function that filters the props object.
 *
 * @example
 * ```tsx
 * const predicate = createPropsPredicate(props, key => key.startsWith("data-"));
 * const dataProps = filterProps(props, predicate);
 * <div {...dataProps} />
 * ```
 */

function createPropsPredicate(props, predicate) {
  const cache = createMemo(() => {
    return {};
  }, undefined, {
    equals: false
  });
  return key => {
    const cacheRef = cache();
    const cached = cacheRef[key];
    if (cached !== undefined) return cached;
    const v = predicate(key);
    cacheRef[key] = v;
    return v;
  };
}

const extractCSSregex = /([^:; ]*):\s*([^;]*)/g;

const isEventListenerKey = key => key[0] === "o" && key[1] === "n" && key.length > 2 && key[2] !== ":" && !key.startsWith("oncapture:");
/**
 * converts inline string styles to object form
 * @example
 * const styles = stringStyleToObject("margin: 24px; border: 1px solid #121212");
 * styles; // { margin: "24px", border: "1px solid #121212" }
 * */


function stringStyleToObject(style) {
  const object = {};
  let match;

  while (match = extractCSSregex.exec(style)) {
    object[match[1]] = match[2];
  }

  return object;
}
/**
 * Combines two set of styles together. Accepts both string and object styles.\
 * @example
 * const styles = combineStyle("margin: 24px; border: 1px solid #121212", {
 *   margin: "2rem",
 *   padding: "16px"
 * });
 * styles; // { margin: "2rem", border: "1px solid #121212", padding: "16px" }
 */

function combineStyle(a, b) {
  if (typeof a === "object" && typeof b === "object") return { ...a,
    ...b
  };
  if (typeof a === "string" && typeof b === "string") return `${a};${b}`;
  const objA = typeof a === "object" ? a : stringStyleToObject(a);
  const objB = typeof b === "object" ? b : stringStyleToObject(b);
  return { ...objA,
    ...objB
  };
}

/**
 * A helper that reactively merges multiple props objects together while smartly combining some of Solid's JSX/DOM attributes.
 *
 * Event handlers and refs are chained, class, classNames and styles are combined.
 * For all other props, the last prop object overrides all previous ones. Similarly to {@link mergeProps}
 * @param sources - Multiple sets of props to combine together.
 * @example
 * ```tsx
 * const MyButton: Component<ButtonProps> = props => {
 *    const { buttonProps } = createButton();
 *    const combined = combineProps(props, buttonProps);
 *    return <button {...combined} />
 * }
 * // component consumer can provide button props
 * // they will be combined with those provided by createButton() primitive
 * <MyButton style={{ margin: "24px" }} />
 * ```
 */
function combineProps(...sources) {
  if (sources.length === 1) return sources[0];
  const merge = mergeProps(...sources);

  const reduce = (key, calc) => {
    let v = undefined;

    for (const props of sources) {
      const propV = props[key];
      if (!v) v = propV;else if (propV) v = calc(v, propV);
    }

    return v;
  }; // create a map of event listeners to be chained


  const listeners = {};

  for (const props of sources) {
    for (const key in props) {
      if (!isEventListenerKey(key)) continue;
      const v = props[key];
      const name = key.toLowerCase();
      let callback;
      if (typeof v === "function") callback = v; // jsx event listeners also accept a tuple [handler, arg]
      else if (Array.isArray(v)) {
        if (v.length === 1) callback = v[0];else callback = v[0].bind(void 0, v[1]);
      } else {
        delete listeners[name];
        continue;
      }
      const callbacks = listeners[name];
      if (!callbacks) listeners[name] = [callback];else callbacks.push(callback);
    }
  }

  return new Proxy(merge, {
    get(target, key) {
      if (typeof key !== "string") return Reflect.get(target, key); // Combine style prop

      if (key === "style") return reduce("style", combineStyle); // chain props.ref assignments

      if (key === "ref") {
        const callbacks = [];

        for (const props of sources) {
          const cb = props[key];
          if (typeof cb === "function") callbacks.push(cb);
        }

        return chain(callbacks);
      } // Chain event listeners


      if (isEventListenerKey(key)) {
        const callbacks = listeners[key.toLowerCase()];
        return Array.isArray(callbacks) ? chain(callbacks) : Reflect.get(target, key);
      } // Merge classes or classNames


      if (key === "class" || key === "className") return reduce(key, (a, b) => `${a} ${b}`); // Merge classList objects, keys in the last object overrides all previous ones.

      if (key === "classList") return reduce(key, (a, b) => ({ ...a,
        ...b
      }));
      return Reflect.get(target, key);
    }

  });
} // const com = combineProps(
//   {
//     onSomething: 123,
//     onWheel: (e: WheelEvent) => 213,
//     something: "foo",
//     style: { margin: "24px" },
//     once: true,
//     onMount: (fn: VoidFunction) => undefined
//   },
//   {
//     onSomething: [(n: number, s: string) => "fo", 123],
//     once: "ovv"
//   },
//   {
//     onWheel: false,
//     onMount: (n: number) => void 0
//   }
// );
// com.onSomething; // (s: string) => void;
// com.once; // string;
// com.onWheel; // false;
// com.onMount; // ((fn: VoidFunction) => undefined) & ((n: number) => undefined);
// com.something; // string;
// com.style; // string | JSX.CSSProperties;

export { BoolProp, NumberProp, SelectProp, StringProp, combineProps, combineStyle, createControlledProp, createControlledProps, createPropsPredicate, filterProps, propTraps, stringStyleToObject };
//# sourceMappingURL=index.js.map
