var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/cookies.ts
var cookies_exports = {};
__export(cookies_exports, {
  cookieStorage: () => cookieStorage,
  createCookieStorage: () => createCookieStorage,
  createCookieStorageSignal: () => createCookieStorageSignal
});
module.exports = __toCommonJS(cookies_exports);

// src/tools.ts
var addClearMethod = (storage) => {
  if (typeof storage.clear === "function") {
    return storage;
  }
  storage.clear = () => {
    let key;
    while (key = storage.key(0)) {
      storage.removeItem(key);
    }
  };
  return storage;
};

// src/storage.ts
var import_solid_js = require("solid-js");
function createStorage(props) {
  const [error, setError] = (0, import_solid_js.createSignal)();
  const handleError = (props == null ? void 0 : props.throw) ? (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
    throw err;
  } : (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
  };
  const apis = (props == null ? void 0 : props.api) ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = (props == null ? void 0 : props.prefix) ? `${props.prefix}.` : "";
  const signals = /* @__PURE__ */ new Map();
  const store = new Proxy({}, {
    get(_, key) {
      let node = signals.get(key);
      if (!node) {
        node = (0, import_solid_js.createSignal)(void 0, { equals: false });
        signals.set(key, node);
      }
      node[0]();
      const value = apis.reduce((result, api) => {
        if (result !== null || !api) {
          return result;
        }
        try {
          return api.getItem(`${prefix}${key}`);
        } catch (err) {
          handleError(err, `Error reading ${prefix}${key} from ${api.name}`);
          return null;
        }
      }, null);
      if (value !== null && (props == null ? void 0 : props.deserializer)) {
        return props.deserializer(value, key, props == null ? void 0 : props.options);
      }
      return value;
    }
  });
  const setter = (key, value, options) => {
    const filteredValue = (props == null ? void 0 : props.serializer) ? props.serializer(value, key, options != null ? options : props == null ? void 0 : props.options) : value;
    const apiKey = `${prefix}${key}`;
    apis.forEach((api) => {
      try {
        api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue);
      } catch (err) {
        handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);
      }
    });
    const node = signals.get(key);
    node && node[1]();
  };
  const remove = (key) => apis.forEach((api) => {
    try {
      api.removeItem(`${prefix}${key}`);
    } catch (err) {
      handleError(err, `Error removing ${prefix}${key} from ${api.name}`);
    }
  });
  const clear = () => apis.forEach((api) => {
    var _a;
    try {
      (_a = api == null ? void 0 : api.clear) == null ? void 0 : _a.call(api);
    } catch (err) {
      handleError(err, `Error clearing ${api.name}`);
    }
  });
  const toJSON = () => {
    const result = {};
    const addValue = (key, value) => {
      if (!result.hasOwnProperty(key)) {
        const filteredValue = value && (props == null ? void 0 : props.deserializer) ? props.deserializer(value, key, props == null ? void 0 : props.options) : value;
        if (filteredValue) {
          result[key] = filteredValue;
        }
      }
    };
    apis.forEach((api) => {
      if (typeof api.getAll === "function") {
        let values;
        try {
          values = api.getAll();
        } catch (err) {
          handleError(err, `Error getting all values from in ${api.name}`);
        }
        for (const key of values) {
          addValue(key, values[key]);
        }
      } else {
        let index = 0, key;
        try {
          while (key = api.key(index++)) {
            if (!result.hasOwnProperty(key)) {
              addValue(key, api.getItem(key));
            }
          }
        } catch (err) {
          handleError(err, `Error getting all values from ${api.name}`);
        }
      }
    });
    return result;
  };
  (props == null ? void 0 : props.sync) !== false && (0, import_solid_js.onMount)(() => {
    const listener = (ev) => {
      var _a;
      let changed = false;
      apis.forEach((api) => {
        try {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        } catch (err) {
          handleError(err, `Error synching api ${api.name} from storage event (${ev.key}=${ev.newValue})`);
        }
      });
      changed && ev.key && ((_a = signals.get(ev.key)) == null ? void 0 : _a[1]());
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      (0, import_solid_js.onCleanup)(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => {
        var _a;
        return (_a = api.addEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      });
      (0, import_solid_js.onCleanup)(() => apis.forEach((api) => {
        var _a;
        return (_a = api.removeEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      }));
    }
  });
  return [
    store,
    setter,
    {
      clear,
      error,
      remove,
      toJSON
    }
  ];
}
function createStorageSignal(key, initialValue, props) {
  var _a;
  const [error, setError] = (0, import_solid_js.createSignal)();
  const apis = (props == null ? void 0 : props.api) ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = (props == null ? void 0 : props.prefix) ? `${props.prefix}.` : "";
  const read = () => apis.reduce((result, api) => {
    if (result !== null || !api) {
      return result;
    }
    let value = null;
    try {
      value = api.getItem(`${prefix}${key}`);
    } catch (err) {
      setError(err instanceof Error ? err : new Error(`Error reading ${prefix}${key} from ${api.name}`));
      if (props == null ? void 0 : props.throw) {
        throw err;
      }
    }
    if (value !== null && (props == null ? void 0 : props.deserializer)) {
      return props.deserializer(value + "", key, props == null ? void 0 : props.options);
    }
    return value;
  }, null);
  const [accessor, setter] = (0, import_solid_js.createSignal)((_a = read()) != null ? _a : initialValue, props);
  (0, import_solid_js.createEffect)(() => {
    const value = accessor();
    const filteredValue = (props == null ? void 0 : props.serializer) ? props.serializer(value, key, props == null ? void 0 : props.options) : value + "";
    const apiKey = `${prefix}${key}`;
    try {
      if (value === null) {
        apis.forEach((api) => api.getItem(apiKey) !== null && api.removeItem(apiKey));
      } else {
        apis.forEach((api) => api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue, props == null ? void 0 : props.options));
      }
    } catch (err) {
      setError(err instanceof Error ? err : new Error(`Error ${value === null ? "removing" : "writing"} value`));
      if (props == null ? void 0 : props.throw) {
        throw err;
      }
    }
  });
  const refetch = () => {
    const value = read();
    setter(value);
  };
  (props == null ? void 0 : props.sync) !== false && (0, import_solid_js.onMount)(() => {
    const listener = (ev) => {
      let changed = false;
      try {
        apis.forEach((api) => {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        });
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Error synching api after event"));
        if (props == null ? void 0 : props.throw) {
          throw err;
        }
      }
      changed && refetch();
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      (0, import_solid_js.onCleanup)(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => {
        var _a2;
        return (_a2 = api.addEventListener) == null ? void 0 : _a2.call(api, "storage", listener);
      });
      (0, import_solid_js.onCleanup)(() => apis.forEach((api) => {
        var _a2;
        return (_a2 = api.removeEventListener) == null ? void 0 : _a2.call(api, "storage", listener);
      }));
    }
  });
  return [Object.assign(accessor, { error }), setter, refetch];
}

// src/cookies.ts
var serializeCookieOptions = (options) => {
  if (!options) {
    return "";
  }
  let memo = "";
  for (const key in options) {
    if (!options.hasOwnProperty(key)) {
      continue;
    }
    const value = options[key];
    memo += value instanceof Date ? `; ${key}=${value.toUTCString()}` : typeof value === "boolean" ? `; ${key}` : `; ${key}=${value}`;
  }
  return memo;
};
var cookieStorage = addClearMethod({
  _cookies: [globalThis.document, "cookie"],
  getItem: (key) => {
    var _a, _b;
    return (_b = (_a = cookieStorage._cookies[0][cookieStorage._cookies[1]].match("(^|;)\\s*" + key + "\\s*=\\s*([^;]+)")) == null ? void 0 : _a.pop()) != null ? _b : null;
  },
  setItem: (key, value, options) => {
    var _a;
    const oldValue = cookieStorage.getItem(key);
    cookieStorage._cookies[0][cookieStorage._cookies[1]] = `${key}=${value}${serializeCookieOptions(options)}`;
    const storageEvent = Object.assign(new Event("storage"), {
      key,
      oldValue,
      newValue: value,
      url: (_a = globalThis.document) == null ? void 0 : _a.URL,
      storageArea: cookieStorage
    });
    window.dispatchEvent(storageEvent);
  },
  removeItem: (key) => {
    cookieStorage._cookies[0][cookieStorage._cookies[1]] = `${key}=deleted${serializeCookieOptions({
      expires: new Date(0)
    })}`;
  },
  key: (index) => {
    let key = null;
    let count = 0;
    cookieStorage._cookies[0][cookieStorage._cookies[1]].replace(/(?:^|;)\s*(.+?)\s*=\s*[^;]+/g, (_, found) => {
      if (!key && found && count++ === index) {
        key = found;
      }
      return "";
    });
    return key;
  },
  get length() {
    let length = 0;
    cookieStorage._cookies[0][cookieStorage._cookies[1]].replace(/(?:^|;)\s*.+?\s*=\s*[^;]+/g, (found) => {
      length += found ? 1 : 0;
      return "";
    });
    return length;
  }
});
var createCookieStorage = (props) => createStorage(__spreadProps(__spreadValues({}, props), { api: cookieStorage }));
var createCookieStorageSignal = (key, initialValue, props) => createStorageSignal(key, initialValue, __spreadProps(__spreadValues({}, props), { api: cookieStorage }));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  cookieStorage,
  createCookieStorage,
  createCookieStorageSignal
});
