import {
  __spreadProps,
  __spreadValues
} from "./chunk-JUWXSDKJ.js";

// src/storage.ts
import { createEffect, createSignal, onCleanup, onMount } from "solid-js";
function createStorage(props) {
  const [error, setError] = createSignal();
  const handleError = (props == null ? void 0 : props.throw) ? (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
    throw err;
  } : (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
  };
  const apis = (props == null ? void 0 : props.api) ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = (props == null ? void 0 : props.prefix) ? `${props.prefix}.` : "";
  const signals = /* @__PURE__ */ new Map();
  const store = new Proxy({}, {
    get(_, key) {
      let node = signals.get(key);
      if (!node) {
        node = createSignal(void 0, { equals: false });
        signals.set(key, node);
      }
      node[0]();
      const value = apis.reduce((result, api) => {
        if (result !== null || !api) {
          return result;
        }
        try {
          return api.getItem(`${prefix}${key}`);
        } catch (err) {
          handleError(err, `Error reading ${prefix}${key} from ${api.name}`);
          return null;
        }
      }, null);
      if (value !== null && (props == null ? void 0 : props.deserializer)) {
        return props.deserializer(value, key, props == null ? void 0 : props.options);
      }
      return value;
    }
  });
  const setter = (key, value, options) => {
    const filteredValue = (props == null ? void 0 : props.serializer) ? props.serializer(value, key, options != null ? options : props == null ? void 0 : props.options) : value;
    const apiKey = `${prefix}${key}`;
    apis.forEach((api) => {
      try {
        api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue);
      } catch (err) {
        handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);
      }
    });
    const node = signals.get(key);
    node && node[1]();
  };
  const remove = (key) => apis.forEach((api) => {
    try {
      api.removeItem(`${prefix}${key}`);
    } catch (err) {
      handleError(err, `Error removing ${prefix}${key} from ${api.name}`);
    }
  });
  const clear = () => apis.forEach((api) => {
    var _a;
    try {
      (_a = api == null ? void 0 : api.clear) == null ? void 0 : _a.call(api);
    } catch (err) {
      handleError(err, `Error clearing ${api.name}`);
    }
  });
  const toJSON = () => {
    const result = {};
    const addValue = (key, value) => {
      if (!result.hasOwnProperty(key)) {
        const filteredValue = value && (props == null ? void 0 : props.deserializer) ? props.deserializer(value, key, props == null ? void 0 : props.options) : value;
        if (filteredValue) {
          result[key] = filteredValue;
        }
      }
    };
    apis.forEach((api) => {
      if (typeof api.getAll === "function") {
        let values;
        try {
          values = api.getAll();
        } catch (err) {
          handleError(err, `Error getting all values from in ${api.name}`);
        }
        for (const key of values) {
          addValue(key, values[key]);
        }
      } else {
        let index = 0, key;
        try {
          while (key = api.key(index++)) {
            if (!result.hasOwnProperty(key)) {
              addValue(key, api.getItem(key));
            }
          }
        } catch (err) {
          handleError(err, `Error getting all values from ${api.name}`);
        }
      }
    });
    return result;
  };
  (props == null ? void 0 : props.sync) !== false && onMount(() => {
    const listener = (ev) => {
      var _a;
      let changed = false;
      apis.forEach((api) => {
        try {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        } catch (err) {
          handleError(err, `Error synching api ${api.name} from storage event (${ev.key}=${ev.newValue})`);
        }
      });
      changed && ev.key && ((_a = signals.get(ev.key)) == null ? void 0 : _a[1]());
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => {
        var _a;
        return (_a = api.addEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      });
      onCleanup(() => apis.forEach((api) => {
        var _a;
        return (_a = api.removeEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      }));
    }
  });
  return [
    store,
    setter,
    {
      clear,
      error,
      remove,
      toJSON
    }
  ];
}
function createAsyncStorage(props) {
  const [error, setError] = createSignal();
  const handleError = (props == null ? void 0 : props.throw) ? (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
    throw err;
  } : (err, fallback) => {
    setError(err instanceof Error ? err : new Error(fallback));
  };
  const apis = (props == null ? void 0 : props.api) ? Array.isArray(props.api) ? props.api : [props.api] : [];
  const prefix = (props == null ? void 0 : props.prefix) ? `${props.prefix}.` : "";
  const signals = /* @__PURE__ */ new Map();
  const store = new Proxy({}, {
    get(_, key) {
      let node = signals.get(key);
      if (!node) {
        node = createSignal(void 0, { equals: false });
        signals.set(key, node);
      }
      node[0]();
      return apis.reduce((result, api) => {
        if (result !== null || !api) {
          return result;
        }
        let value;
        try {
          value = api.getItem(`${prefix}${key}`);
        } catch (err) {
          handleError(err, `Error getting ${prefix}${key} from ${api.name}`);
        }
        if (value instanceof Promise) {
          return value.then((value2) => value2 && (props == null ? void 0 : props.deserializer) ? props.deserializer(value2, key, props == null ? void 0 : props.options) : value2);
        }
        return value !== null && (props == null ? void 0 : props.deserializer) ? Promise.resolve(props.deserializer(value, key, props == null ? void 0 : props.options)) : Promise.resolve(value);
      }, null);
    }
  });
  const setter = (key, value, options) => {
    const filteredValue = (props == null ? void 0 : props.serializer) ? props.serializer(value, key, options != null ? options : props == null ? void 0 : props.options) : value;
    return Promise.all(apis.map((api) => {
      try {
        api.setItem(`${prefix}${key}`, filteredValue, options != null ? options : props == null ? void 0 : props.options);
      } catch (err) {
        handleError(err, `Error setting ${prefix}${key} to ${filteredValue} in ${api.name}`);
      }
    })).then(() => {
      const node = signals.get(key);
      node && node[1]();
    });
  };
  const remove = (key) => {
    Promise.all(apis.map((api) => {
      try {
        api.removeItem(`${prefix}${key}`);
      } catch (err) {
        handleError(err, `Error removing ${prefix}${key} from ${api.name}`);
      }
    })).then(() => {
      const node = signals.get(key);
      node && node[1]();
    });
  };
  const clear = () => Promise.all(apis.map(async (api) => {
    let index = 0, key;
    while (key = await api.key(index++)) {
      try {
        await api.removeItem(key);
      } catch (err) {
        handleError(err, `Error removing ${key} from ${api.name} during clear()`);
      }
    }
  })).then(() => {
    return;
  });
  const toJSON = async () => {
    const result = {};
    const addValue = (key, value) => {
      if (!result.hasOwnProperty(key)) {
        const filteredValue = value && (props == null ? void 0 : props.deserializer) ? props.deserializer(value, key, props == null ? void 0 : props.options) : value;
        if (filteredValue) {
          result[key] = filteredValue;
        }
      }
    };
    await Promise.all(apis.map(async (api) => {
      if (typeof api.getAll === "function") {
        try {
          const values = await api.getAll();
          for (const key of values) {
            addValue(key, values[key]);
          }
        } catch (err) {
          handleError(err, `Error attempting to get all keys from ${api.name}`);
        }
      } else {
        let index = 0, key;
        try {
          while (key = await api.key(index++)) {
            addValue(key, await api.getItem(key));
          }
        } catch (err) {
          handleError(err, `Error attempting to get all keys from ${api.name}`);
        }
      }
    }));
    return result;
  };
  (props == null ? void 0 : props.sync) !== false && onMount(() => {
    const listener = (ev) => {
      var _a;
      let changed = false;
      apis.forEach(async (api) => {
        try {
          if (api !== ev.storageArea && ev.key && ev.newValue !== await api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        } catch (err) {
          handleError(err, "Error attempting to sync on event");
        }
      });
      changed && ev.key && ((_a = signals.get(ev.key)) == null ? void 0 : _a[1]());
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => {
        var _a;
        return (_a = api.addEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      });
      onCleanup(() => apis.forEach((api) => {
        var _a;
        return (_a = api.removeEventListener) == null ? void 0 : _a.call(api, "storage", listener);
      }));
    }
  });
  return [
    store,
    setter,
    {
      remove,
      clear,
      error,
      toJSON
    }
  ];
}
function createStorageSignal(key, initialValue, props) {
  var _a;
  const [error, setError] = createSignal();
  const apis = (props == null ? void 0 : props.api) ? Array.isArray(props.api) ? props.api : [props.api] : [globalThis.localStorage].filter(Boolean);
  const prefix = (props == null ? void 0 : props.prefix) ? `${props.prefix}.` : "";
  const read = () => apis.reduce((result, api) => {
    if (result !== null || !api) {
      return result;
    }
    let value = null;
    try {
      value = api.getItem(`${prefix}${key}`);
    } catch (err) {
      setError(err instanceof Error ? err : new Error(`Error reading ${prefix}${key} from ${api.name}`));
      if (props == null ? void 0 : props.throw) {
        throw err;
      }
    }
    if (value !== null && (props == null ? void 0 : props.deserializer)) {
      return props.deserializer(value + "", key, props == null ? void 0 : props.options);
    }
    return value;
  }, null);
  const [accessor, setter] = createSignal((_a = read()) != null ? _a : initialValue, props);
  createEffect(() => {
    const value = accessor();
    const filteredValue = (props == null ? void 0 : props.serializer) ? props.serializer(value, key, props == null ? void 0 : props.options) : value + "";
    const apiKey = `${prefix}${key}`;
    try {
      if (value === null) {
        apis.forEach((api) => api.getItem(apiKey) !== null && api.removeItem(apiKey));
      } else {
        apis.forEach((api) => api.getItem(apiKey) !== filteredValue && api.setItem(apiKey, filteredValue, props == null ? void 0 : props.options));
      }
    } catch (err) {
      setError(err instanceof Error ? err : new Error(`Error ${value === null ? "removing" : "writing"} value`));
      if (props == null ? void 0 : props.throw) {
        throw err;
      }
    }
  });
  const refetch = () => {
    const value = read();
    setter(value);
  };
  (props == null ? void 0 : props.sync) !== false && onMount(() => {
    const listener = (ev) => {
      let changed = false;
      try {
        apis.forEach((api) => {
          if (api !== ev.storageArea && ev.key && ev.newValue !== api.getItem(ev.key)) {
            ev.newValue ? api.setItem(ev.key, ev.newValue) : api.removeItem(ev.key);
            changed = true;
          }
        });
      } catch (err) {
        setError(err instanceof Error ? err : new Error("Error synching api after event"));
        if (props == null ? void 0 : props.throw) {
          throw err;
        }
      }
      changed && refetch();
    };
    if ("addEventListener" in globalThis) {
      globalThis.addEventListener("storage", listener);
      onCleanup(() => globalThis.removeEventListener("storage", listener));
    } else {
      apis.forEach((api) => {
        var _a2;
        return (_a2 = api.addEventListener) == null ? void 0 : _a2.call(api, "storage", listener);
      });
      onCleanup(() => apis.forEach((api) => {
        var _a2;
        return (_a2 = api.removeEventListener) == null ? void 0 : _a2.call(api, "storage", listener);
      }));
    }
  });
  return [Object.assign(accessor, { error }), setter, refetch];
}
var createLocalStorage = createStorage;
var createSessionStorage = (props) => createStorage(__spreadProps(__spreadValues({}, props), { api: globalThis.sessionStorage }));

export {
  createStorage,
  createAsyncStorage,
  createStorageSignal,
  createLocalStorage,
  createSessionStorage
};
