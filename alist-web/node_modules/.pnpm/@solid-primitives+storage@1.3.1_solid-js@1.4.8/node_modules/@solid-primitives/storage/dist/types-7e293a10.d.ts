declare type StorageWithOptions<O> = {
    clear: () => void;
    getItem: (key: string, options?: O) => string | null;
    getAll?: () => {
        [key: string]: any;
    };
    setItem: (key: string, value: string, options?: O) => void;
    removeItem: (key: string) => void;
    key: (index: number) => string | null;
    readonly length: number | undefined;
    [key: string]: any;
};
declare type StorageDeserializer<T, O> = (value: string, key: string, options?: O) => T;
declare type StorageSerializer<T, O> = (value: T, key: string, options?: O) => string;
declare type AnyStorageProps<A, O, T> = {
    /** a Storage-like API, e.g. localStorage */
    api?: A | A[];
    /** a function that parses the stored data after retrieval */
    deserializer?: StorageDeserializer<T, O>;
    /** a function that serializes the data before storing */
    serializer?: StorageSerializer<T, O>;
    /** options for the Storage-like API, if supported */
    options?: O;
    /** a prefix for the keys */
    prefix?: string;
    /** should the storage be synchronized via Storage events, default is `true`? */
    sync?: boolean;
    /** errors will be thrown and need to be caught in an ErrorBoundary, default is `false` */
    throw?: boolean;
};
declare type StringStorageProps<A, O, T = string> = AnyStorageProps<A, O, T>;
declare type StorageProps<T, A, O> = T extends string ? StringStorageProps<A, O> : AnyStorageProps<A, O, T>;
declare type StorageObject<T> = Record<string, T>;
declare type StorageSetter<T, O> = (key: string, value: T, options?: O) => void;
declare type StorageActions<T> = {
    remove: (key: string) => void;
    clear: () => void;
    error: () => Error | undefined;
    toJSON: () => {
        [key: string]: T;
    };
};
declare type AsyncStorage = {
    clear?: () => Promise<void> | void;
    getItem: (key: string) => Promise<string | null> | string | null;
    getAll?: () => Promise<any>;
    setItem: (key: string, value: string) => Promise<void> | void;
    removeItem: (key: string) => Promise<void> | void;
    key: (index: number) => Promise<string | null> | string | null;
    readonly length: number | undefined;
    [key: string]: any;
};
declare type AsyncStorageWithOptions<O> = {
    clear?: () => Promise<void> | void;
    getItem: (key: string, options?: O) => Promise<string | null> | string | null;
    getAll?: () => Promise<any>;
    setItem: (key: string, value: string, options?: O) => Promise<void> | void;
    removeItem: (key: string) => Promise<void> | void;
    key: (index: number) => Promise<string | null> | string | null;
    readonly length: number | undefined;
    [key: string]: any;
};
declare type AsyncStorageObject<T> = Record<string, Promise<T | null>>;
declare type AsyncStorageSetter<T, O> = (key: string, value: T, options?: O) => Promise<void> | void;
declare type AsyncStorageActions<T> = {
    remove: (key: string) => Promise<void> | void;
    clear: () => Promise<void> | void;
    error: () => Error | undefined;
    toJSON: () => Promise<{
        [key: string]: T;
    }>;
};
declare type StorageSignalProps<T, A, O> = StorageProps<T, A, O> & {
    /** signal equality checker */
    equals?: false | ((prev: T, next: T) => boolean);
    /** signal name used in dev mode */
    name?: string;
    internal?: boolean;
    /** should the storage be synchronized via Storage events, default is `true`? */
    sync?: boolean;
    /** errors will be thrown and need to be caught in an ErrorBoundary, default is `false` */
    throw?: boolean;
};

export { AnyStorageProps as A, StorageWithOptions as S, StorageDeserializer as a, StorageSerializer as b, StringStorageProps as c, StorageProps as d, StorageObject as e, StorageSetter as f, AsyncStorage as g, AsyncStorageWithOptions as h, AsyncStorageObject as i, AsyncStorageSetter as j, StorageSignalProps as k, StorageActions as l, AsyncStorageActions as m };
